<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HOUSING CRISIS SIMULATION</title>
<style>
  :root{
    --bg:#0f172a;        /* slate-950 */
    --ink:#e2e8f0;       /* slate-200 */
    --muted:#94a3b8;     /* slate-400 */
    --good:#34d399;      /* emerald */
    --warn:#f59e0b;      /* amber */
    --bad:#ef4444;       /* red */
    --accent:#60a5fa;    /* blue */
    --steel:#7dd3fc;     /* sky */
    --wood:#f59e0b;      /* amber */
    --concrete:#cbd5e1;  /* slate-300 */
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;}
  #wrap{position:fixed;inset:0;display:flex;align-items:stretch;justify-content:stretch}
  canvas{display:block;flex:1;outline:none;cursor:crosshair;position:relative;z-index:1}
  /* HUD */
  #hud{
    position:fixed;left:12px;top:12px;z-index:2;
    background:rgba(15,23,42,.6);backdrop-filter:saturate(120%) blur(6px);
    border:1px solid rgba(148,163,184,.25);border-radius:12px;padding:10px 12px;min-width:280px;
    box-shadow:0 10px 30px rgba(0,0,0,.35)
  }
  #hud h1{margin:0 0 6px 0;font-size:14px;letter-spacing:.04em;color:var(--muted);font-weight:600}
  #stats{display:grid;grid-template-columns:auto 1fr auto;gap:4px 10px;align-items:center;font-size:13px}
  #stats .label{color:var(--muted)}
  #stats .val{font-variant-numeric:tabular-nums}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:rgba(148,163,184,.15);border:1px solid rgba(148,163,184,.25)}
  .dot{width:8px;height:8px;border-radius:50%}
  .wood .dot{background:var(--wood)} .concrete .dot{background:var(--concrete)} .steel .dot{background:var(--steel)}
  .good{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  #cta{position:fixed;right:12px;top:12px;z-index:2;display:flex;gap:8px}
  .btn{
    display:inline-flex;align-items:center;justify-content:center;gap:6px;
    padding:10px 14px;border-radius:10px;border:1px solid rgba(148,163,184,.25);background:rgba(2,6,23,.5);
    color:var(--ink);font-weight:600;letter-spacing:.02em;cursor:pointer;user-select:none;text-decoration:none
  }
  button.btn{font:inherit;}
  .btn:hover{background:rgba(2,6,23,.75)}
  /* Stress meter overlay */
  #stress{
    pointer-events:none;position:fixed;inset:0;z-index:0;overflow:hidden;
    background:rgba(15,23,42,.1);
  }
  #stress .stress-fill{
    position:absolute;inset:0;transform-origin:left center;transform:scaleX(0);
    background:linear-gradient(90deg, rgba(147,197,253,.35), rgba(239,68,68,.9));
    opacity:.75;mix-blend-mode:screen;transition:filter .25s ease, opacity .25s ease;
  }
  #stress.is-warning .stress-fill{
    background:linear-gradient(90deg, rgba(251,191,36,.45), rgba(239,68,68,.95));
    opacity:.85;
  }
  #stress.is-danger .stress-fill{
    background:linear-gradient(90deg, rgba(248,113,113,.6), rgba(239,68,68,1));
    animation:stressFlash .5s steps(2,start) infinite;
    opacity:1;
  }
  @keyframes stressFlash{
    0%,100%{filter:brightness(1);}
    50%{filter:brightness(1.75);}
  }
  #introOverlay{
    position:fixed;inset:0;z-index:5;display:flex;align-items:center;justify-content:center;
    padding:24px;background:rgba(15,23,42,.9);backdrop-filter:blur(12px);
    transition:opacity .3s ease;
  }
  #introOverlay.hidden{opacity:0;pointer-events:none;}
  #introOverlay .panel{
    background:rgba(15,23,42,.92);border:1px solid rgba(148,163,184,.35);border-radius:18px;
    padding:32px 34px;max-width:420px;text-align:left;box-shadow:0 18px 40px rgba(0,0,0,.45);
  }
  #introOverlay h2{margin:0 0 14px;font-size:22px;letter-spacing:.03em;text-align:center;}
  #introOverlay p{margin:0 0 16px;font-size:15px;line-height:1.6;color:var(--muted);text-align:center;}
  #introOverlay ul{margin:0 0 20px;padding:0;list-style:none;font-size:14px;line-height:1.55;color:var(--muted);}
  #introOverlay ul li{display:flex;gap:10px;margin-bottom:10px;}
  #introOverlay ul li::before{content:'*';color:var(--accent);margin-top:1px;font-size:18px;line-height:1;}
  #introOverlay .actions{display:flex;justify-content:center;gap:10px;flex-wrap:wrap;}
  #introOverlay .actions .btn{min-width:140px;}

  #gameOverOverlay{
    position:fixed;inset:0;z-index:4;display:flex;align-items:center;justify-content:center;
    padding:24px;background:rgba(15,23,42,.9);backdrop-filter:blur(10px);
    opacity:0;pointer-events:none;transition:opacity .3s ease;
  }
  #gameOverOverlay.show{
    opacity:1;pointer-events:auto;
  }
  #gameOverOverlay .panel{
    background:rgba(15,23,42,.92);border:1px solid rgba(148,163,184,.35);border-radius:16px;
    padding:26px 28px;max-width:360px;text-align:center;box-shadow:0 18px 40px rgba(0,0,0,.45);
  }
  #gameOverOverlay .panel h2{
    margin:0 0 12px;font-size:20px;letter-spacing:.02em;
  }
  #gameOverOverlay .panel p{
    margin:0 0 22px;font-size:14px;line-height:1.5;color:var(--muted);
  }
  #gameOverOverlay .scorecard{
    display:grid;grid-template-columns:auto auto;gap:8px 16px;justify-content:center;
    margin:0 0 18px;font-size:15px;
  }
  #gameOverOverlay .scorecard .label{color:var(--muted);text-align:right;text-transform:uppercase;letter-spacing:.05em;font-size:12px;}
  #gameOverOverlay .scorecard .value{color:var(--ink);font-weight:600;font-size:16px;}
  #gameOverOverlay .score-total{
    font-size:18px;font-weight:700;margin:0 0 24px;color:var(--good);text-transform:uppercase;letter-spacing:.06em;
  }
  #gameOverOverlay .score-total.score-neutral{color:var(--muted);}
  #gameOverOverlay .score-total.score-bad{color:var(--bad);}
  #gameOverOverlay .actions{
    display:flex;gap:10px;flex-wrap:wrap;justify-content:center;
  }
  #gameOverOverlay .actions .btn{
    min-width:120px;
  }
  #gameOverOverlay .actions .btn.alt{
    background:rgba(2,6,23,.35);border-color:rgba(148,163,184,.45);
  }
  #toast{
    position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
    background:rgba(15,23,42,.85);border:1px solid rgba(148,163,184,.3);border-radius:12px;padding:10px 14px;
    font-size:13px;color:var(--ink);opacity:0;transition:opacity .3s ease-out;z-index:3
  }
  #toast.show{opacity:1}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" aria-label="Housing Balance Game" tabindex="0"></canvas>
  <div id="stress" aria-hidden="true">
    <div class="stress-fill"></div>
  </div>
</div>

<div id="hud" role="region" aria-label="Game status">
  <h1>HOUSING CRISIS SIMULATION</h1>
  <div id="stats">
    <div class="label">Inventory</div><div></div>
    <div class="val">
      <span class="pill wood" title="Wood"><span class="dot"></span><span id="woodCnt">0</span></span>
      <span class="pill concrete" title="Concrete"><span class="dot"></span><span id="concreteCnt">0</span></span>
      <span class="pill steel" title="Steel"><span class="dot"></span><span id="steelCnt">0</span></span>
    </div>
    <div class="label">Housed</div><div></div><div class="val"><span id="housedCnt">0</span></div>
    <div class="label">Waiting</div><div></div><div class="val"><span id="waitingCnt">0</span></div>
    <div class="label">Spawn rate</div><div></div><div class="val"><span id="spawnRate">1.5s â†’ faster</span></div>
    <div class="label">Tip</div><div></div><div class="val">Collect Materials â†’ Build Houses â†’ House People</div>
  </div>
</div>

<div id="cta">
  <div class="btn" id="resetBtn">Reset</div>
  <div class="btn" id="pauseBtn">Pause</div>
  <div class="btn" id="slowBtn" title="Accessibility: slow the game pace">Slow Mode</div>
</div>

<div id="introOverlay" role="dialog" aria-modal="true">
  <div class="panel">
    <h2>Welcome to the Housing Crisis Simulation</h2>
    <p>Balance limited materials and time to house as many neighbors as you can.</p>
    <ul>
      <li>Click supply drops to gather wood, concrete, and steel.</li>
      <li>When you hold one of each material, click the map to place a house.</li>
      <li>Drag waiting neighbors into houses that still have room.</li>
      <li>Too many unhoused neighbors max out the stress meter and end the run.</li>
    </ul>
    <p>Need breathing room? Pause or flip on Slow Mode with the controls in the top right.</p>
    <div class="actions">
      <button class="btn" id="startBtn" type="button">Start Game</button>
    </div>
  </div>
</div>
<div id="gameOverOverlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="panel">
    <h2 id="gameOverTitle">Stress Limit Reached</h2>
    <p id="gameOverMessage">Stress has overwhelmed the community. What would you like to do?</p>
    <div class="scorecard" aria-live="polite">
      <span class="label">People housed</span><span class="value" id="finalHoused">0</span>
      <span class="label">Waiting unhoused</span><span class="value" id="finalWaiting">0</span>
    </div>
    <div class="score-total" id="finalScoreWrap">Final score <span id="finalScore">0</span></div>
    <div class="actions">
      <button class="btn" id="resumeBtn" type="button">Resume</button>
      <button class="btn" id="overlayResetBtn" type="button">Restart</button>
      <button class="btn" id="overlaySlowBtn" type="button">Slow Mode</button>
      <a class="btn alt" id="homeBtn" href="index.html">Return Home</a>
    </div>
  </div>
</div>

<div id="toast" role="status" aria-live="polite"></div>

<script>
(()=>{
// ---------- Helpers ----------
const rand = (a,b)=>Math.random()*(b-a)+a;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const hud = {
  wood: document.getElementById('woodCnt'),
  concrete: document.getElementById('concreteCnt'),
  steel: document.getElementById('steelCnt'),
  housed: document.getElementById('housedCnt'),
  waiting: document.getElementById('waitingCnt'),
  spawn: document.getElementById('spawnRate'),
};
const stress = document.getElementById('stress');
const stressFill = stress.querySelector('.stress-fill');
const toastEl = document.getElementById('toast');
const resetBtn = document.getElementById('resetBtn');
const pauseBtn = document.getElementById('pauseBtn');
const slowBtn = document.getElementById('slowBtn');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const gameOverTitle = document.getElementById('gameOverTitle');
const gameOverMessage = document.getElementById('gameOverMessage');
const resumeBtn = document.getElementById('resumeBtn');
const overlayResetBtn = document.getElementById('overlayResetBtn');
const overlaySlowBtn = document.getElementById('overlaySlowBtn');
const finalHoused = document.getElementById('finalHoused');
const finalWaiting = document.getElementById('finalWaiting');
const finalScoreWrap = document.getElementById('finalScoreWrap');
const finalScoreVal = document.getElementById('finalScore');
const introOverlay = document.getElementById('introOverlay');
const startBtn = document.getElementById('startBtn');

let W=innerWidth, H=innerHeight;
const DPR = clamp(devicePixelRatio||1,1,2);

function resize(){
  W=innerWidth; H=innerHeight;
  canvas.width = W*DPR; canvas.height = H*DPR; canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize, {passive:true});
resize();

// ---------- Game State ----------
const state = {
  t:0, dt:0, last:performance.now(),
  people:[], items:[], houses:[],
  inventory:{wood:0, concrete:0, steel:0},
  housed:0,
  dragging:null, dragOff:{x:0,y:0},
  placingHouse:false,
  personSpawnInterval:1500, // ms; shrinks over time
  lastSpawn:0,
  gameOver:false,
  slow:false,
  paused:false,
  started:false,
  waiting:0,
  stressLevel:0,
  stressTarget:0,
  stressWarning:false,
  stressDanger:false,
};

const COLORS = {
  bg:'#0b1229',
  ground:'#0b132f',
  person:'#e2e8f0',
  impatient:'#f87171',
  house:'#60a5fa',
  houseDoor:'#0f172a',
  steel:'#7dd3fc',
  wood:'#f59e0b',
  concrete:'#cbd5e1',
  outline:'rgba(255,255,255,.12)'
};

const LIMITS = {
  maxPeople: 150,
  patience: 18000, // ms before turning impatient (visual)
  failAt: 20,      // waiting people threshold to show strong stress
  spawnMin: 100,   // minimum spawn interval
  houseCapacity: 5, // people per house
  itemTTL: 12000,
  itemSpawnEvery: 1200,
  itemMax: 12
};

const STRESS = {
  warn:0.55,
  danger:0.85,
  riseMs:2600,
  fallMs:1400,
  gameOver:0.995,
};

// ---------- Entities ----------
function spawnItem(){
  if(state.items.length>=LIMITS.itemMax) return;
  const types=['wood','concrete','steel'];
  const type = types[(Math.random()*types.length)|0];
  const m=64;
  state.items.push({
    id:crypto.randomUUID(), type,
    x: rand(m,W-m), y: rand(m,H*0.65),
    ttl: LIMITS.itemTTL
  });
}

function spawnPerson(){
  const edge = Math.random()<0.5?'left':'right';
  const y = rand(H*0.15,H*0.85);
  const x = (edge==='left')? -20 : W+20;
  state.people.push({
    id:crypto.randomUUID(),
    x,y, r:10,
    vx: (edge==='left')? rand(0.35,0.8): rand(-0.8,-0.35),
    vy: rand(-0.2,0.2),
    housed:false,
    tBorn: state.t,
    impatient:false
  });
}

function placeHouseAt(x,y){
  state.houses.push({
    id:crypto.randomUUID(),
    x,y, w:60,h:56, cap: LIMITS.houseCapacity, inside:0
  });
  state.placingHouse=false;
  notify('House built (+4 capacity)');
}

function craftCheck(){
  const inv=state.inventory;
  if(inv.wood>=1 && inv.concrete>=1 && inv.steel>=1){
    inv.wood--; inv.concrete--; inv.steel--;
    state.placingHouse=true;
    notify('Click to place your house');
  }
}

// ---------- Input ----------
const pointer = {x:W/2,y:H/2, down:false};
canvas.addEventListener('mousemove', e=>{
  const rect=canvas.getBoundingClientRect();
  pointer.x = e.clientX-rect.left;
  pointer.y = e.clientY-rect.top;
  if(state.dragging){
    state.dragging.x = pointer.x + state.dragOff.x;
    state.dragging.y = pointer.y + state.dragOff.y;
  }
},{passive:true});

canvas.addEventListener('mousedown', e=>{
  pointer.down=true;
  if(state.gameOver) return;
  // If placing house, place where clicked (but avoid edges)
  if(state.placingHouse){
    const m=50;
    const x=clamp(pointer.x,m,W-m), y=clamp(pointer.y,H*0.25,H*0.9-m);
    placeHouseAt(x,y);
    return;
  }
  // Try grab a person (priority)
  for(let i=state.people.length-1;i>=0;i--){
    const p=state.people[i];
    if(p.housed) continue;
    if(Math.hypot(pointer.x-p.x, pointer.y-p.y) <= p.r+4){
      state.dragging=p;
      state.dragOff.x = p.x-pointer.x;
      state.dragOff.y = p.y-pointer.y;
      return;
    }
  }
  // Otherwise, click item to collect
  for(let i=state.items.length-1;i>=0;i--){
    const it=state.items[i];
    if(Math.abs(pointer.x-it.x)<=18 && Math.abs(pointer.y-it.y)<=18){
      state.items.splice(i,1);
      state.inventory[it.type]++;
      updateHUD();
      craftCheck();
      return;
    }
  }
});

addEventListener('mouseup', ()=>{
  pointer.down=false;
  if(state.gameOver){
    state.dragging=null;
    return;
  }
  if(state.dragging){
    // drop person: if over a house with space, house them
    const p=state.dragging; state.dragging=null;
    const house = state.houses.find(h=>(
      pointer.x > h.x-h.w/2 && pointer.x < h.x+h.w/2 &&
      pointer.y > h.y-h.h && pointer.y < h.y
    ));
    if(house && house.inside < house.cap){
      house.inside++;
      p.housed=true;
      state.housed++;
      notify('Housed +1');
      updateHUD();
    }
  }
},{passive:true});

// Buttons
resetBtn.addEventListener('click', ()=>reset());
pauseBtn.addEventListener('click', ()=>{
  if(state.gameOver) return;
  if(!state.started) return;
  if(state.paused){
    resumeGame();
  } else {
    pauseGame();
  }
});
resumeBtn.addEventListener('click', ()=>resumeGame());
overlayResetBtn.addEventListener('click', ()=>reset());
slowBtn.addEventListener('click', ()=>toggleSlowMode());
overlaySlowBtn.addEventListener('click', ()=>toggleSlowMode());
if(startBtn){
  startBtn.addEventListener('click', ()=>{
    if(state.started) return;
    hideIntro();
    state.started = true;
    state.paused = false;
    state.last = performance.now();
    pauseBtn.textContent = 'Pause';
    canvas.focus({preventScroll:true});
  });
}
updateSlowLabels();

// ---------- Loop ----------
function update(now){
  state.dt = now - state.last; state.last = now; state.t += state.dt;
  if(state.gameOver || state.paused) return;
  const scale = state.slow? 0.55 : 1;

  // Spawn items
  if(state.t % (LIMITS.itemSpawnEvery/scale) < state.dt){
    spawnItem();
  }
  // Spawn people faster over time
  if(now - state.lastSpawn > state.personSpawnInterval/scale){
    spawnPerson();
    state.lastSpawn = now;
    state.personSpawnInterval = Math.max(LIMITS.spawnMin, state.personSpawnInterval - (6*scale)); // ramps difficulty
    hud.spawn.textContent = (state.personSpawnInterval/1000).toFixed(1)+'s â†’ faster';
  }

  // Move people (not dragged)
  for(const p of state.people){
    if(p.housed) continue;
    if(state.dragging===p) continue;
    // Walk
    p.x += p.vx * scale * (1 + Math.random()*0.2);
    p.y += p.vy * scale;
    // Bounce a bit vertically
    if(p.y< H*0.18 || p.y> H*0.9) p.vy*=-1;
    // Seek nearest house if any with space
    const target = nearestHouseWithSpace(p);
    if(target){
      const tx = clamp(target.x, 0, W), ty = clamp(target.y-20, 0, H);
      const dx = tx - p.x, dy = ty - p.y, d = Math.hypot(dx,dy)||1;
      const speed = 0.35*scale;
      p.x += (dx/d)*speed; p.y += (dy/d)*speed;
    }
    // mark impatient
    if(!p.impatient && (state.t - p.tBorn) > LIMITS.patience/ (state.slow?0.7:1)){
      p.impatient = true;
    }
  }

  // Cull far offscreen people (fail state if too many waiting)
  const waiting = state.people.filter(p=>!p.housed).length;
  hud.waiting.textContent = waiting;
  state.waiting = waiting;

  state.stressTarget = clamp(waiting / LIMITS.failAt, 0, 1);
  const rising = state.stressTarget > state.stressLevel;
  const rate = clamp(state.dt / (rising ? STRESS.riseMs : STRESS.fallMs), 0, 1);
  state.stressLevel += (state.stressTarget - state.stressLevel) * rate;
  state.stressLevel = clamp(state.stressLevel, 0, 1);

  const danger = state.stressLevel > STRESS.danger;
  const warning = state.stressLevel > STRESS.warn && !danger;
  state.stressDanger = danger;
  state.stressWarning = warning;
  stress.classList.toggle('is-warning', warning);
  stress.classList.toggle('is-danger', danger);
  stressFill.style.transform = `scaleX(${state.stressLevel})`;

  if(!state.gameOver && state.stressLevel >= STRESS.gameOver){
    gameOver({
      title: 'Stress Limit Reached',
      message: 'Stress has overwhelmed the community. Would you like to try again or return home?',
    });
  }

  if(waiting > LIMITS.maxPeople && !state.gameOver){
    gameOver({
      title: 'Overwhelmed',
      message: 'Too many neighbors are waiting for housing. Try balancing inventory and housing placements.',
    });
  }

  // Items TTL
  for(let i=state.items.length-1;i>=0;i--){
    state.items[i].ttl -= state.dt*scale;
    if(state.items[i].ttl<=0) state.items.splice(i,1);
  }
}

function drawStressOverlay(){
  if(state.stressLevel <= 0.001) return;
  const width = Math.max(W * state.stressLevel, 1);
  ctx.save();
  const gradient = ctx.createLinearGradient(0, 0, width, 0);
  gradient.addColorStop(0, state.stressDanger ? 'rgba(248,113,113,0.45)' : 'rgba(147,197,253,0.35)');
  gradient.addColorStop(1, state.stressDanger ? 'rgba(239,68,68,0.95)' : (state.stressWarning ? 'rgba(251,191,36,0.65)' : 'rgba(239,68,68,0.75)'));
  const baseOpacity = state.stressDanger ? 0.85 : state.stressWarning ? 0.6 : 0.45;
  const flash = state.stressDanger ? (0.8 + 0.2*Math.sin(state.t / 120)) : 1;
  ctx.globalAlpha = baseOpacity * flash;
  ctx.globalCompositeOperation = 'screen';
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, H);
  ctx.restore();
}

function draw(){
  // bg
  ctx.clearRect(0,0,W,H);
  // ground gradient
  const g = ctx.createLinearGradient(0,H*0.2,0,H);
  g.addColorStop(0, '#0b142f'); g.addColorStop(1, COLORS.ground);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

drawStressOverlay();

  // Houses
  for(const h of state.houses){
    drawHouse(h);
  }

  // Items
  for(const it of state.items){
    drawItem(it);
  }

  // People
  for(const p of state.people){
    drawPerson(p);
  }

  // House ghost (placement)
  if(state.placingHouse){
    drawHouseGhost(pointer.x, pointer.y);
  }

  // Drag hint
  if(state.dragging){
    ctx.save();
    ctx.strokeStyle='rgba(96,165,250,.8)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth=2;
    ctx.strokeRect(pointer.x-24, pointer.y-24, 48, 48);
    ctx.restore();
  }
}

function frame(now){
  update(now);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// ---------- Rendering ----------
function drawItem(it){
  ctx.save();
  ctx.translate(it.x, it.y);
  // base
  ctx.globalAlpha = 0.95;
  ctx.strokeStyle = 'rgba(255,255,255,.15)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();
  ctx.globalAlpha = 1;

  // glyph
  if(it.type==='wood'){
    ctx.fillStyle = COLORS.wood;
    ctx.rotate(0.2);
    ctx.fillRect(-12,-5,24,10);
    ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.strokeRect(-12,-5,24,10);
  } else if(it.type==='concrete'){
    ctx.fillStyle = COLORS.concrete;
    ctx.fillRect(-12,-12,24,24);
    ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.strokeRect(-12,-12,24,24);
  } else {
    ctx.fillStyle = COLORS.steel;
    ctx.beginPath();
    ctx.moveTo(0,-14); ctx.lineTo(12,12); ctx.lineTo(-12,12); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

function drawPerson(p){
  ctx.save();
  ctx.translate(p.x, p.y);
  // shadow
  ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.ellipse(0, p.r+10, 14,6,0,0,Math.PI*2); ctx.fill();

  // body
  ctx.fillStyle = p.impatient ? COLORS.impatient : COLORS.person;
  ctx.beginPath();
  ctx.arc(0,-p.r-6, 6, 0, Math.PI*2); // head
  ctx.fill();
  ctx.fillRect(-5,-p.r, 10, 18);      // torso
  // legs
  ctx.fillRect(-7, 6, 5, 10);
  ctx.fillRect( 2, 6, 5, 10);
  // outline when draggable
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.strokeRect(-12,-p.r-10,24,28);
  ctx.restore();
}

function drawHouse(h){
  ctx.save();
  ctx.translate(h.x, h.y);
  // body
  ctx.fillStyle=COLORS.house;
  roundRect(-h.w/2, -h.h, h.w, h.h-8, 8, true, false);
  // roof
  ctx.fillStyle='#3b82f6';
  ctx.beginPath();
  ctx.moveTo(-h.w/2-4, -h.h+12);
  ctx.lineTo(0, -h.h-14);
  ctx.lineTo(h.w/2+4, -h.h+12);
  ctx.closePath(); ctx.fill();
  // door
  ctx.fillStyle=COLORS.houseDoor;
  ctx.fillRect(-10,-22,20,22);
  // capacity pips
  for(let i=0;i<h.cap;i++){
    const filled = i < h.inside;
    ctx.fillStyle = filled? '#22c55e' : 'rgba(255,255,255,.25)';
    ctx.beginPath(); ctx.arc(-h.w/2 + 12 + i*12, -h.h-22, 4, 0, Math.PI*2); ctx.fill();
  }
  // stroke
  ctx.strokeStyle='rgba(255,255,255,.15)';
  ctx.lineWidth=2; ctx.strokeRect(-h.w/2, -h.h, h.w, h.h-8);
  ctx.restore();
}
function drawHouseGhost(x,y){
  const w=60,h=56;
  ctx.save();
  ctx.translate(x,y);
  ctx.globalAlpha=0.5;
  ctx.fillStyle='#60a5fa';
  roundRect(-w/2, -h, w, h-8, 8, true, false);
  ctx.fillStyle='#3b82f6';
  ctx.beginPath(); ctx.moveTo(-w/2-4,-h+12); ctx.lineTo(0,-h-14); ctx.lineTo(w/2+4,-h+12); ctx.closePath(); ctx.fill();
  ctx.restore();
}
function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

function nearestHouseWithSpace(p){
  let best=null, bestD=1e9;
  for(const h of state.houses){
    if(h.inside>=h.cap) continue;
    const d = Math.hypot(p.x-h.x, p.y-(h.y-20));
    if(d<bestD){bestD=d; best=h;}
  }
  return best;
}

// ---------- HUD / UX ----------
function updateHUD(){
  hud.wood.textContent = state.inventory.wood;
  hud.concrete.textContent = state.inventory.concrete;
  hud.steel.textContent = state.inventory.steel;
  hud.housed.textContent = state.housed;
}

let toastTimer=null;
function notify(msg){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 1400);
}

function showIntro(){
  if(!introOverlay) return;
  introOverlay.classList.remove('hidden');
  introOverlay.removeAttribute('aria-hidden');
  if(startBtn){
    setTimeout(()=>startBtn.focus({preventScroll:true}), 80);
  }
}

function hideIntro(){
  if(!introOverlay) return;
  introOverlay.classList.add('hidden');
  introOverlay.setAttribute('aria-hidden','true');
}
function updateSlowLabels(){
  const label = state.slow ? 'Normal Mode' : 'Slow Mode';
  slowBtn.textContent = label;
  overlaySlowBtn.textContent = label;
}

function toggleSlowMode(){
  state.slow = !state.slow;
  updateSlowLabels();
  notify(state.slow? 'Slow mode ON' : 'Slow mode OFF');
}

function updateScoreboard(){
  const housed = state.housed;
  const waiting = state.waiting;
  const score = housed - waiting;
  finalHoused.textContent = housed;
  finalWaiting.textContent = waiting;
  finalScoreVal.textContent = score;
  finalScoreWrap.classList.remove('score-neutral','score-bad');
  if(score < 0){
    finalScoreWrap.classList.add('score-bad');
  } else if(score === 0){
    finalScoreWrap.classList.add('score-neutral');
  }
  return score;
}

function openOverlay({mode, title, message}){
  gameOverTitle.textContent = title;
  gameOverMessage.textContent = message;
  resumeBtn.style.display = mode === 'pause' ? 'inline-flex' : 'none';
  overlayResetBtn.textContent = mode === 'gameOver' ? 'Restart' : 'Reset';
  updateSlowLabels();
  gameOverOverlay.classList.add('show');
  gameOverOverlay.removeAttribute('aria-hidden');
  const focusTarget = mode === 'pause' ? resumeBtn : overlayResetBtn;
  if(focusTarget){
    setTimeout(()=>focusTarget.focus({preventScroll:true}), 80);
  }
}

function closeOverlay(){
  gameOverOverlay.classList.remove('show');
  gameOverOverlay.setAttribute('aria-hidden','true');
}

function pauseGame(){
  if(state.gameOver || state.paused) return;
  state.paused = true;
  updateScoreboard();
  openOverlay({mode:'pause', title:'Paused', message:'Take a breather. Adjust strategy or resume when ready.'});
  pauseBtn.textContent = 'Resume';
}

function resumeGame(){
  if(!state.paused) return;
  state.paused = false;
  state.started = true;
  closeOverlay();
  pauseBtn.textContent = 'Pause';
}

function gameOver({title='Game Over', message='Too many neighbors are waiting.'} = {}){
  if(state.gameOver) return;
  state.gameOver=true;
  state.paused=false;
  pauseBtn.textContent = 'Pause';
  state.dragging=null;
  state.placingHouse=false;

  updateScoreboard();
  notify(title);
  openOverlay({mode:'gameOver', title, message});
}


// ---------- Reset ----------
function reset({silent=false, keepPaused=false} = {}){
  Object.assign(state, {
    ...state,
    t:0, dt:0, last:performance.now(),
    people:[], items:[], houses:[],
    inventory:{wood:0, concrete:0, steel:0},
    housed:0, dragging:null, dragOff:{x:0,y:0},
    placingHouse:false,
    personSpawnInterval:1500, lastSpawn:0, gameOver:false,
    paused:keepPaused,
    started:!keepPaused,
    waiting:0,
    stressLevel:0, stressTarget:0,
    stressWarning:false, stressDanger:false
  });
  updateHUD();
  stress.classList.remove('is-warning','is-danger');
  stressFill.style.transform='scaleX(0)';
  closeOverlay();
  pauseBtn.textContent = 'Pause';
  updateSlowLabels();
  finalHoused.textContent = '0';
  finalWaiting.textContent = '0';
  finalScoreVal.textContent = '0';
  finalScoreWrap.classList.remove('score-neutral','score-bad');
  if(!silent){
    notify('Reset');
  }
  if(!keepPaused){
    hideIntro();
  }
}
reset({silent:true, keepPaused:true});
showIntro();

})();</script>
</body>
</html>

